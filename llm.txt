# Verb - High-Performance Multi-Protocol Server Framework for Bun

> **Version**: 1.0.1 | **Author**: Wess Cope | **License**: MIT
> **Homepage**: https://verb.codes | **Repository**: https://github.com/wess/verb

## Overview

Verb is a production-ready, high-performance server framework built exclusively for Bun runtime. It provides a unified API for building applications across multiple protocols (HTTP, HTTPS, HTTP/2, WebSocket, gRPC, UDP, TCP, TLS) with complete TypeScript support and functional programming patterns.

**Key Capabilities**: Multi-protocol support, Enterprise security, React SSR, File uploads, Real-time features, Development tools (HMR), Performance optimization, Testing utilities

**Zero Runtime Dependencies**: Verb uses only Bun built-in APIs - no external runtime dependencies.

## Project Structure

```
verb/
├── src/
│   ├── index.ts              # Main export hub
│   ├── types.ts              # Core TypeScript types
│   ├── request.ts            # Request enhancement
│   ├── response.ts           # Response builder (fluent API)
│   ├── middleware.ts         # Built-in middleware
│   ├── upload.ts             # File upload handling
│   ├── utils.ts              # Utility functions
│   ├── router/               # Routing system
│   │   ├── index.ts          # Router API (static + radix)
│   │   ├── radix.ts          # Radix tree implementation
│   │   └── types.ts          # Router types
│   ├── server/               # Server implementations
│   │   ├── base.ts           # Core HTTP server
│   │   ├── unified.ts        # Protocol factory
│   │   ├── http.ts           # HTTP server
│   │   ├── https.ts          # HTTPS server
│   │   ├── http2.ts          # HTTP/2 server
│   │   ├── websocket.ts      # WebSocket server
│   │   ├── grpc.ts           # gRPC server (basic)
│   │   ├── tcp.ts            # TCP server
│   │   ├── udp.ts            # UDP server
│   │   └── tls.ts            # TLS server
│   ├── security/             # Security middleware
│   │   └── index.ts          # CORS, rate limiting, headers
│   ├── errors/               # Error handling
│   │   ├── index.ts          # Error classes
│   │   └── middleware.ts     # Error middleware
│   ├── applications/         # Sub-application support
│   ├── content-negotiation/  # Accept header parsing
│   ├── development/          # HMR and dev tools
│   ├── validation/           # Request validation
│   └── middleware/
│       └── json-optimized.ts # Schema-based JSON validation
├── tests/                    # Test suites (16 categories)
├── examples/                 # Example applications (20+)
├── scripts/                  # Build and version scripts
├── package.json
├── tsconfig.json
└── biome.json               # Linter/formatter config
```

## Framework Architecture

### Core Design Principles
- **Zero Classes in API**: Pure functional programming approach - handlers are functions
- **Bun-First**: Native integration with Bun APIs (Bun.serve, Bun.file)
- **TypeScript-First**: Complete type safety with advanced inference
- **Protocol Agnostic**: Single codebase supporting 12 network protocols
- **Performance Focused**: O(1) static routing, radix tree for dynamic routes
- **Express.js Compatible**: Migration-friendly API surface
- **Production Ready**: Enterprise security, monitoring, health checks
- **Zero Runtime Dependencies**: Uses only Bun built-ins

### Installation & Quick Start
```bash
bun add verb
```

```typescript
import { createServer } from "verb";

const app = createServer();
app.get("/", (req, res) => res.json({ message: "Hello World" }));
app.listen(3000);
```

## Core Exports

```typescript
// Main exports from "verb"
export {
  // Server creation
  createServer,
  createUnifiedServer,
  createProtocolGateway,
  createProtocolGatewayWithState,
  server,                    // Fluent helper: server.http(), server.websocket()
  ServerProtocol,            // Enum of all protocols

  // Router
  createRouter,

  // Middleware namespace
  middleware,                // middleware.json(), middleware.static(), etc.

  // Security (re-exported from security module)
  trustProxy,
  rateLimit,
  cors,
  securityHeaders,
  createSecurityMiddleware,
  securityPresets,           // .development(), .production(), .api()

  // Errors
  HttpError,
  BadRequestError,
  UnauthorizedError,
  ForbiddenError,
  NotFoundError,
  MethodNotAllowedError,
  ConflictError,
  UnprocessableEntityError,
  TooManyRequestsError,
  InternalServerError,
  NotImplementedError,
  BadGatewayError,
  ServiceUnavailableError,
  createError,
  asyncHandler,
  errorBoundary,

  // Types (re-exported)
  type VerbRequest,
  type VerbResponse,
  type Handler,
  type Middleware,
  type ErrorHandler,
  type Method,
  type ServerInstance,
  type Context,
  type Router,
  type RouteMatch,
  type RouteInfo,
}
```

## Server Creation (Multi-Protocol)

```typescript
import { createServer, server, ServerProtocol } from "verb";

// Basic HTTP server (default)
const app = createServer();

// Protocol-specific servers
const httpServer = createServer(ServerProtocol.HTTP);
const httpsServer = createServer(ServerProtocol.HTTPS);
const http2Server = createServer(ServerProtocol.HTTP2);
const wsServer = createServer(ServerProtocol.WEBSOCKET);
const grpcServer = createServer(ServerProtocol.GRPC);
const udpServer = createServer(ServerProtocol.UDP);
const tcpServer = createServer(ServerProtocol.TCP);

// Fluent API alternative
const app2 = server.http();
const wsApp = server.websocket();
const grpcApp = server.grpc();

// Multi-protocol gateway
import { createProtocolGateway } from "verb";
const gateway = createProtocolGateway({
  http: { port: 3000 },
  websocket: { port: 3001 },
  grpc: { port: 3002 }
});
```

### Protocol Enum
```typescript
enum ServerProtocol {
  HTTP = "http",
  HTTPS = "https",
  HTTP2 = "http2",
  HTTP2S = "http2s",
  WEBSOCKET = "websocket",
  WEBSOCKETS = "websockets",
  GRPC = "grpc",
  GRPCS = "grpcs",
  UDP = "udp",
  DTLS = "dtls",
  TCP = "tcp",
  TLS = "tls",
}
```

## Enhanced Request Object (VerbRequest)

```typescript
type VerbRequest = globalThis.Request & {
  // Route & Query Data
  params?: Record<string, string>;        // Route parameters (/users/:id)
  query?: Record<string, string>;         // Query string (?search=term)
  body?: any;                             // Parsed body (JSON/form/raw)
  _bodyParsed?: boolean;                  // Body parsing flag

  // Client Information
  cookies?: Record<string, string>;       // Parsed cookies
  ip?: string;                            // Client IP (proxy-aware)
  path?: string;                          // Request path
  hostname?: string;                      // Request hostname
  protocol?: string;                      // Protocol (http/https)
  secure?: boolean;                       // HTTPS flag
  xhr?: boolean;                          // XMLHttpRequest detection

  // Form Data (file uploads)
  formData?: () => Promise<{
    fields: Record<string, string>;
    files: Record<string, any>
  }>;

  // Content Negotiation
  get?: (header: string) => string | undefined;
  accepts?: (types?: string | string[]) => string | string[] | null;
  acceptsCharsets?: (charsets?: string | string[]) => string | string[] | null;
  acceptsEncodings?: (encodings?: string | string[]) => string | string[] | null;
  acceptsLanguages?: (languages?: string | string[]) => string | string[] | null;
};
```

## Response Object (VerbResponse)

```typescript
type VerbResponse = {
  // Content Methods
  send: (data: string | object | number | boolean) => VerbResponse;
  json: (data: any) => VerbResponse;
  html: (content: string) => VerbResponse;
  text: (content: string) => VerbResponse;
  react: (component: any, props?: any) => VerbResponse;  // SSR support

  // Status & Redirects
  status: (code: number) => VerbResponse;
  redirect: (url: string, code?: number) => VerbResponse;

  // Headers & Cookies
  header: (name: string, value: string) => VerbResponse;
  headers: (headers: Record<string, string>) => VerbResponse;
  cookie: (name: string, value: string, options?: any) => VerbResponse;
  clearCookie: (name: string) => VerbResponse;
  type: (contentType: string) => VerbResponse;
  vary: (header: string) => VerbResponse;

  // File Operations
  attachment: (filename?: string) => VerbResponse;
  download: (path: string, filename?: string, options?: any) => Promise<VerbResponse>;
  sendFile: (path: string, options?: any) => Promise<VerbResponse>;

  // Response Control
  end: () => VerbResponse;
};
```

## Handler & Middleware Types

```typescript
type Method = "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "HEAD" | "OPTIONS";

type Handler = (
  req: VerbRequest,
  res: VerbResponse,
) => void | Promise<void> | VerbResponse | Promise<VerbResponse>;

type Middleware = (
  req: VerbRequest,
  res: VerbResponse,
  next: () => void,
) => void | Promise<void>;

type ErrorHandler = (
  err: Error,
  req: VerbRequest,
  res: VerbResponse,
  next: () => void,
) => void | Promise<void>;

type MiddlewareHandler = Middleware | Handler | ErrorHandler;
```

## Routing System

### Hybrid Router Architecture
Verb uses a hybrid routing strategy for maximum performance:
- **Static Routes**: O(1) Map-based lookup for exact path matches
- **Dynamic Routes**: Radix tree with O(path depth) complexity
- **Parameter Extraction**: Supports `:named`, `:param(regex)`, and `*` wildcard
- **Trailing Slash**: Automatic normalization

### Router Implementation
```typescript
// src/router/index.ts - Public API
const createRouter = (): Router => {
  const staticRoutes = new Map();  // O(1) lookup
  const radix = createRadixRouter(); // For dynamic routes

  // Static routes: method:path -> handler
  // Dynamic routes: radix tree traversal
}

// src/router/radix.ts - Radix Tree
// Supports:
// - :named parameters
// - :param(\\d+) regex patterns
// - * wildcard (captures rest of path)
// - Hierarchical node structure
// - decodeURIComponent on matches
```

### Basic Routing
```typescript
// HTTP Methods
app.get("/", handler);
app.post("/users", handler);
app.put("/users/:id", handler);
app.delete("/users/:id", handler);
app.patch("/users/:id", handler);
app.head("/users", handler);
app.options("/users", handler);

// Pattern Matching
app.get("/users/:id", handler);           // Named parameter
app.get("/users/:id(\\d+)", handler);     // Numeric ID only (regex)
app.get("/files/*", handler);             // Wildcard (rest of path)

// Multiple Paths
app.get(["/", "/home", "/index"], handler);

// Route Chaining
app.route("/users")
  .get(getAllUsers)
  .post(createUser)
  .put(updateUser)
  .delete(deleteUser);

// Multiple Middleware
app.get("/protected",
  authenticateUser,
  checkPermissions,
  logAccess,
  (req, res) => res.json({ data: "secret" })
);
```

### Router API
```typescript
import { createRouter } from "verb";

const router = createRouter();

// Add routes
router.add("GET", "/users", [], handler);
router.add("GET", "/users/:id", [authMiddleware], handler);

// Match routes
const match = router.match("GET", "/users/123");
// Returns: { handler, middlewares, params: { id: "123" } } | null

// Get all routes
const routes = router.routes();
// Returns: RouteInfo[]
```

## Built-in Middleware

```typescript
import { middleware } from "verb";

// Body Parsing
app.use(middleware.json({
  limit: "100kb",           // Size limit (default: "100kb")
  strict: true,             // Require object/array (default: true)
  type: "application/json", // Content-Type to parse
  verify: (req, res, buf, encoding) => {} // Optional verification
}));

app.use(middleware.urlencoded({
  extended: true,           // Support nested objects (default: true)
  limit: "100kb",
  parameterLimit: 1000      // Max parameters (default: 1000)
}));

app.use(middleware.raw({ limit: "100kb" }));
app.use(middleware.text({ limit: "100kb" }));

// Static File Serving (Express.static compatible)
app.use(middleware.static("public", {
  index: "index.html",      // Directory index (default: "index.html")
  extensions: [],           // Try extensions if not found
  maxAge: 0,                // Cache-Control max-age
  etag: true,               // Generate ETags (default: true)
  lastModified: true,       // Last-Modified header (default: true)
  dotfiles: "ignore",       // "allow" | "deny" | "ignore"
  fallthrough: true,        // Pass to next middleware if not found
  immutable: false,         // Cache-Control immutable
  redirect: true            // Redirect directories to trailing slash
}));

// Alias for Express compatibility
app.use(middleware.staticFiles("public"));
```

## Security Middleware

```typescript
import { trustProxy, rateLimit, cors, securityHeaders, securityPresets } from "verb";

// Trust Proxy (for load balancers)
app.use(trustProxy({
  enabled: true,
  trustedProxies: ["127.0.0.1", "10.0.0.0/8"],
  trustAll: false
}));

// Rate Limiting (in-memory store)
app.use(rateLimit({
  windowMs: 15 * 60 * 1000,  // 15 minutes
  max: 100,                   // Requests per window
  message: "Too many requests from this IP",
  standardHeaders: true,      // RateLimit-* headers
  legacyHeaders: false,       // X-RateLimit-* headers
  keyGenerator: (req) => req.ip || "unknown",
  skipFailedRequests: false,
  skipSuccessfulRequests: false,
  onLimitReached: (req, res) => {}
}));

// CORS
app.use(cors({
  origin: "*",                // string | string[] | boolean | function
  methods: ["GET", "HEAD", "PUT", "PATCH", "POST", "DELETE"],
  allowedHeaders: ["Content-Type", "Authorization"],
  exposedHeaders: [],
  credentials: false,
  maxAge: 86400,              // Preflight cache (24 hours)
  optionsSuccessStatus: 204
}));

// Security Headers (Helmet-equivalent)
app.use(securityHeaders({
  contentSecurityPolicy: "default-src 'self'",
  dnsPrefetchControl: true,
  frameguard: { action: "deny" },  // "deny" | "sameorigin" | "allowfrom"
  hidePoweredBy: true,
  hsts: { maxAge: 31536000, includeSubDomains: true, preload: false },
  ieNoOpen: true,
  noSniff: true,
  originAgentCluster: true,
  permittedCrossDomainPolicies: "none",
  referrerPolicy: "no-referrer",
  xssFilter: true
}));

// Security Presets
app.use(...securityPresets.development());  // Permissive for dev
app.use(...securityPresets.production());   // Strict for production
app.use(...securityPresets.api());          // Optimized for APIs
```

## Error Handling

### Error Classes
```typescript
import {
  HttpError,
  BadRequestError,        // 400
  UnauthorizedError,      // 401
  ForbiddenError,         // 403
  NotFoundError,          // 404
  MethodNotAllowedError,  // 405
  ConflictError,          // 409
  UnprocessableEntityError, // 422
  TooManyRequestsError,   // 429
  InternalServerError,    // 500
  NotImplementedError,    // 501
  BadGatewayError,        // 502
  ServiceUnavailableError, // 503
  createError,
  asyncHandler,
  errorBoundary
} from "verb";

// Usage
throw new NotFoundError("User not found");
throw new BadRequestError("Invalid input");
throw createError(418, "I'm a teapot");

// Error boundary wrapper
app.get("/api/users/:id", errorBoundary(async (req, res) => {
  const user = await UserService.getById(req.params.id);
  if (!user) throw new NotFoundError();
  res.json(user);
}));

// Async handler (catches async errors)
app.get("/api/data", asyncHandler(async (req, res) => {
  const data = await fetchData();
  res.json(data);
}));
```

### Error Helpers
```typescript
import {
  authenticationError,     // Creates UnauthorizedError
  authorizationError,      // Creates ForbiddenError
  rateLimitError,          // Creates TooManyRequestsError
  timeoutError,            // Creates 408 error
  fileTooLargeError,       // Creates 413 error
  unsupportedMediaTypeError, // Creates 415 error
  databaseError,           // Creates InternalServerError
  validationError          // Creates UnprocessableEntityError
} from "verb";
```

## Bun Native Fullstack Development

### HTML Imports with Automatic Bundling
```typescript
import { createServer } from "verb";
import homepage from "./index.html";

const app = createServer();

app.withRoutes({
  // Static HTML pages (Bun bundles automatically)
  "/": homepage,

  // REST API endpoints
  "/api/users": {
    async GET(req) {
      const users = await UserService.getAll();
      return Response.json(users);
    },
    async POST(req) {
      const userData = await req.json();
      const user = await UserService.create(userData);
      return Response.json(user, { status: 201 });
    }
  },

  // Parameterized routes
  "/api/users/:id": {
    async GET(req) {
      const { id } = req.params;
      const user = await UserService.getById(id);
      return user ? Response.json(user) : new Response("Not Found", { status: 404 });
    }
  },

  // WebSocket endpoints
  "/ws/chat": {
    message: (ws, message) => {
      ws.publish("chat", message);
    },
    open: (ws) => {
      ws.subscribe("chat");
    },
    close: (ws) => {
      console.log("Client disconnected");
    }
  }
});

app.withOptions({
  development: {
    hmr: true,
    console: true
  }
});
```

## WebSocket Server

```typescript
const wsServer = createServer(ServerProtocol.WEBSOCKET);

wsServer.ws("/chat/:room", {
  message: (ws, message) => {
    const { room } = ws.data.params;
    ws.publish(`chat:${room}`, JSON.stringify({
      message: JSON.parse(message),
      timestamp: Date.now()
    }));
  },

  open: (ws) => {
    const { room } = ws.data.params;
    ws.subscribe(`chat:${room}`);
    ws.send(JSON.stringify({ type: "welcome" }));
  },

  close: (ws) => {
    const { room } = ws.data.params;
    console.log(`Client left ${room}`);
  },

  drain: (ws) => {
    console.log("WebSocket backpressure relieved");
  }
});

// HTTP routes work alongside WebSocket
wsServer.get("/chat/:room", (req, res) => {
  res.html(`<script>const ws = new WebSocket('ws://localhost:3000/chat/${req.params.room}');</script>`);
});
```

## Application Settings & Context

```typescript
const app = createServer();

// Settings (key-value store)
app.set("trust proxy", true);
app.set("env", "production");
app.set("view cache", true);

const env = app.getSetting("env");

// Context API (typed app-wide state)
app.context.set("db", database);
app.context.set("cache", redisClient);

const db = app.context.get("db");
const allContext = app.context.all();
```

## Sub-Applications

```typescript
import { createServer } from "verb";

const app = createServer();
const apiRouter = createServer();
const adminRouter = createServer();

// API routes
apiRouter.get("/users", (req, res) => res.json({ users: [] }));
apiRouter.post("/users", (req, res) => res.json({ created: true }));

// Admin routes
adminRouter.get("/dashboard", (req, res) => res.html("<h1>Admin</h1>"));

// Mount sub-applications
app.use("/api", apiRouter);
app.use("/admin", adminRouter);

// Mountpath available on sub-apps
console.log(apiRouter.mountpath); // "/api"
console.log(apiRouter.path());    // Returns full path
```

## File Upload Handling

```typescript
app.post("/upload", async (req, res) => {
  try {
    const { fields, files } = await req.formData();

    // Access uploaded files
    const uploadedFile = files.file[0];
    console.log(uploadedFile.name, uploadedFile.size, uploadedFile.type);

    // Access form fields
    console.log(fields.title);

    res.json({ success: true, filename: uploadedFile.name });
  } catch (error) {
    res.status(400).json({ error: "Upload failed" });
  }
});
```

## Content Negotiation

```typescript
app.get("/data", (req, res) => {
  // Check accepted content types
  const type = req.accepts(["json", "html", "xml"]);

  switch (type) {
    case "json":
      res.json({ data: "value" });
      break;
    case "html":
      res.html("<p>Data: value</p>");
      break;
    case "xml":
      res.type("application/xml").send("<data>value</data>");
      break;
    default:
      res.status(406).send("Not Acceptable");
  }
});

// Other content negotiation methods
req.acceptsCharsets(["utf-8", "iso-8859-1"]);
req.acceptsEncodings(["gzip", "deflate"]);
req.acceptsLanguages(["en", "es", "fr"]);
```

## Development Features

```typescript
import { createServer } from "verb";

const app = createServer();

// Enable HMR and enhanced console
app.listen(3000, "localhost");
app.withOptions({
  development: {
    hmr: true,
    console: true
  },
  showRoutes: true  // Display registered routes on startup
});
```

## Testing

Verb includes 16 test categories covering:
- Router matching (static, dynamic, wildcards, regex)
- Middleware execution chains
- Request/response parsing
- Error handling
- Security middleware
- Content negotiation
- Sub-applications
- File uploads
- WebSocket handlers

```typescript
// Test setup example
import { createServer } from "verb";
import { test, expect } from "bun:test";

const app = createServer();
app.get("/api/users", (req, res) => res.json({ users: [] }));

// Create test handler
const handler = app.createFetchHandler();

test("GET /api/users returns users", async () => {
  const response = await handler(new Request("http://localhost/api/users"));
  const data = await response.json();

  expect(response.status).toBe(200);
  expect(data).toEqual({ users: [] });
});
```

## Graceful Shutdown

```typescript
import { gracefulShutdown } from "verb";

const server = app.listen(3000);

gracefulShutdown(server, {
  timeout: 30000,
  onShutdown: async () => {
    console.log("Shutting down...");
    await cleanup();
  }
});
```

## Implementation Status

### Fully Implemented
- HTTP/HTTPS servers (via Bun.serve)
- Hybrid router (static O(1) + radix tree)
- Middleware system (global, path-specific, route-specific)
- Body parsers (json, urlencoded, raw, text)
- Static file serving with caching
- Security middleware (CORS, rate limiting, headers)
- Request enhancement (cookies, IP, content negotiation)
- Response fluent API
- Error classes (12 HTTP error types)
- File upload handling (multipart form data)
- Sub-applications and mounting
- Context/settings API
- WebSocket handlers
- React SSR support

### Basic/Simplified Implementations
- gRPC server (basic structure, not full protobuf)
- UDP/DTLS servers (basic functionality)
- TCP/TLS servers (basic functionality)
- HTTP/2 (structure exists, limited features)

## Examples

The `/examples` directory contains 20+ examples:
- `basic.ts` - Simple HTTP server
- `middleware.ts` - Middleware usage
- `built-in-middleware.ts` - All built-in middleware
- `enhanced-routing.ts` - Advanced routing patterns
- `returnable-responses.ts` - Fluent API patterns
- `json-optimization.ts` - Schema validation
- `unified-protocols.ts` - Protocol switching
- `show-routes.ts` - Route listing
- `development.ts` - HMR/dev mode
- `/fullstack/` - HTML imports with Bun routes
- `/file-upload/` - File upload handling
- `/static/` - Static file serving
- `/error-handling/` - Error handling patterns
- `/security/` - Security features
- `/content-negotiation/` - Content type handling

## Express.js Compatibility

Verb is designed to be migration-friendly from Express.js:

```typescript
// Express.js pattern
app.use(express.json());
app.use(express.static("public"));
app.get("/users/:id", (req, res) => {
  res.json({ id: req.params.id });
});

// Equivalent Verb pattern
app.use(middleware.json());
app.use(middleware.static("public"));
app.get("/users/:id", (req, res) => {
  res.json({ id: req.params.id });
});
```

## Performance Characteristics

- **Static Routes**: O(1) Map lookup
- **Dynamic Routes**: O(path depth) radix tree traversal
- **Middleware**: Linear pipeline with early exit support
- **Response Building**: Lazy construction, single Response creation
- **Memory**: Minimal allocations, reuses buffers where possible
- **Startup**: Sub-millisecond route registration

## Requirements

- **Bun**: >= 1.0.0 (required)
- **TypeScript**: ^5.8.3 (peer dependency)
- **React/React-DOM**: Optional, for SSR features
